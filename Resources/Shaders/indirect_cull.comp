#version 450

layout (local_size_x = 256) in;

struct ObjectData{
	mat4 model;
	vec4 sphereBounds;
};

struct DrawCommand
{
	uint    indexCount;
    uint    instanceCount;
    uint    firstIndex;
    int     vertexOffset;
    uint    firstInstance;
	uint batchID;
	uint dataID;
};

struct GPUInstance {
	uint batchID;
	uint dataID;
};

layout (set = 0, binding = 0) uniform CullingGlobalData {
	mat4 view;
	vec4 frustum[6];  // Left/right/top/bottom frustum planes
	uint nbInstances;
	bool cullingEnabled;
} globalData;


layout (set = 0, binding = 1) uniform CameraData {
    mat4 view;
    mat4 proj;
	mat4 viewproj;
} camera;

layout (std140, set = 0, binding = 2) readonly buffer ObjectBuffer{
	ObjectData objects[];
} objectBuffer;

layout (set = 0, binding = 3)  buffer DrawBuffer {
	DrawCommand drawsCommands[];
} drawBuffer;

layout (set = 0, binding = 4) readonly buffer InstanceBuffer {
	GPUInstance gpuInstances[];
} instanceBuffer;

layout (set = 0, binding = 5) buffer IndexMap {
	uint map[];
} objectDataIndices;

layout(set = 0, binding = 6) uniform sampler2D depthPyramid;

bool IsVisible(uint objectDataIndex)
{
return true;
	vec4 sphereBounds = objectBuffer.objects[objectDataIndex].sphereBounds;
	vec3 center = (camera.view * vec4(sphereBounds.xyz, 1.f)).xyz;
	float radius = sphereBounds.w;

	bool visible = true;
	
	for (int i = 0; i < 6; ++i) {
		visible = visible && (dot(globalData.frustum[i].xyz, center) > -radius);
	}

	visible = visible || (!globalData.cullingEnabled);

	return visible;
}


void main()
{
	uint gID = gl_GlobalInvocationID.x;
	if (gID < globalData.nbInstances) {
		uint batchIndex = instanceBuffer.gpuInstances[gID].batchID;
		uint dataIndex = instanceBuffer.gpuInstances[gID].dataID;
		if (IsVisible(dataIndex)) {
			uint count = atomicAdd(drawBuffer.drawsCommands[batchIndex].instanceCount, 1);
			
			uint instanceIndex = drawBuffer.drawsCommands[batchIndex].firstInstance + count;
			objectDataIndices.map[instanceIndex] = dataIndex;
		}
	}
}
